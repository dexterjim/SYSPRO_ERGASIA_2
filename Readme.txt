ΛΑΖΑΡΙΔΗΣ ΔΗΜΗΤΡΙΟΣ 1115201400086

Compile: make
Run (παραδείγματα εκτέλεσης):	./mirror_client -n 1 -c ./common/ -i ./input-files/infiles/ -m ./mirror-files/m1/ -b 5 -l ./log-files/log_file1
				./mirror_client -n 2 -c ./common/ -i ./input-files/infiles/Cy/ -m ./mirror-files/m2/ -b 50 -l ./log-files/log_file2
				./mirror_client -n 3 -c ./common/ -i ./input-files/infiles/NKU/ -m ./mirror-files/m3/ -b 35 -l ./log-files/log_file3
 -Για το create_infiles.sh:	./scripts/create_infiles.sh ./input-files/infiles 10 7 4
 -Για το get_stats.sh:		cat ./log-files/log_file1 ./log-files/log_file2 ./log-files/log_file3 | ./scripts/get_stats.sh
(Τα παραπάνω παραδείγματα τα εκτελούμε από τον αρχικό φάκελο)
*Ολοι οι φάκελοι πρέπει να τελειώνουν σε '/'

A) mirror_client :
	-main.c :
		Η συνάρτηση εκτελεί την βασική λειτουργία των clients δηλ , αρχικά διαβάζει και
		ελέγχει τα ορίσματα ενεργοποιεί τα signals φτιάχνει την λίστα με τους
		άλλους clients που θα συνδεθεί .Στην συνέχεια μπαίνει σε μια while η οποία
		περιοδικά ελέγχει για νέα id αρχεία ή για αρχεία που λείπουν. Στην περίπτωση
		που βρει νέο αρχείο το προσθέτει στην λίστα και κάνει fork 2 παιδια , ένα
		sender_child που αναλαμβάνει να στείλει τα αρχεία που έχει στο input_dir o client
		και ένα receiver_child που αναλαμβάνει να πάρει τα αρχεία που θα στείλει ο άλλος
		client (περισσότερες πληροφορίες για την λειτουργία τους υπάρχουν παρακάτω).
		Για να ψάξει για clients που έχουν αποσυνδεθεί αρχικά καλεί την συνάρτηση
		initializeZeroList η οποία μηδενίζει το πεδίο still_exist , έπειτα καθώς ελέγχω
		τα αρχεία του common για κάθε id που βρίκσω αλλάζω την τιμή της σε 1 , δηλ 
		"μαρκάρω" το αρχείο ότι υπάρχει ακόμα (αυτή η ενέργεια γίνεται στη searchList).
		Στο τέλος όσα αρχεία έχουν αυτό το πεδίο 0 σημαίνει ότι πρέπει να τα σβήσω
		οπότε καλώ το cleaner_child το οποίο αναλαμβάνει αυτή την δουλειά.Η διαδικασία αυτή
		γίνεται περιοδικά με την χρήση της sleep που παίρνει σαν όρισμα την define
		μεταβλητή PERIOD για το κάθε πόσα δευτερόλεπτα θα γίνεται έλεγχος.Για να φύγουμε
		από την while πρέπει να δεχτεί ctrl^C ή ctrl^\ τα οποία εκτελούν ακριβώς την ίδια
		λειτουργία , κάνουν την global μεταβλητή flag_to_quit=1 και μετά στην αρχή της
		επανάληψης ελέγχω αν αυτή η τιμή είναι ==1 ώστε να κάνω break.Αφού γίνει break
		εκτελείται το βήμα 6 δηλ ο client σβήνει όλο το τοπικό mirror_dir , το *.id αρχείο
		του από το common, ανανεώνει το logfile γράφοντας σε αυτό ότι ο συγκεκριμένος client
		έφυγε και κάνει free.
		


	-functions.h :
		Το αρχείο αυτό έχει μόνο μια δομή η οποία κρατάει όλα τα arguments.
	-functions.c :
		-int takeArguments(struct_arguments **arguments,int argc,char **argv) : Η
		συνάρτηση αυτή διαβάζει τα ορίσματα και ελέγχει ότι ο χρήστης τα έδωσε όλα.
		-int checkAndCreateDirs(struct_arguments *arguments) : Η συνάρτηση αυτή ελέγχει
		αν υπάρχει ο φάκελος input_dir και αν δεν υπάρχει εμφανίζει μνμ λάθους.
		Επιπλέων ελέγχει αν υπάρχει ο φάκελος mirror_dir , αν υπάρχει εμφανίζει μνμ
		λάθους αλλίως τον δημιουργεί και τέλος φτιάχνει το common_dir αν δεν υπάρχει.
		-int createFileInCommon(struct_arguments *arguments) : Η συνάρτηση αυτή φτιάχνει
		ένα αρχείο της μορφής *.id μέσα στον common_dir. Αυτό το κάνει κολλώντας στο τέλος
		του common_dir το όνομα του αρχείου το δημιουργεί και βάζει μέσα το id του process
		-int createLogFile(struct_arguments *arguments) : Μια απλή συνάρτηση η οποία
		φτιάχνει το logfile και γράφει σε αυτό το μνμ "id=*", δηλ ότι δημιουργήθηκε νέος
		client.
		-int countDigits(int x) : Μία απλή συνάρτηση όπου μετράει πόσα digits έχει ο χ.
		-int isDirectory(const char *path) : Μία απλή συνάρτηση που ελέγχει αν το path
		είναι Directory.
		-void cleanDirOrFile(char *directory_or_file) : Η συνάρτηση αυτή διαγράφει
		αναδρομικά όλα τα στοιχεία του directory_or_file.Αυτό το κάνει με τον εξής τρόπο
		, αρχικά ελέγχει αν πρόκειται για αρχείο η για φάκελο , στην περίπτωση του
		αρχείου απλά το διαγράφει και τέλος , στην περίπτωση του φακέλου τον ανοίγει
		και καλέι την συνάρτηση για όλα τα στοιχεία που έχει μέσα,το μονοπάτι το
		φτιάχνει βάζωντας στο τέλος του directory_or_file το νέο στοιχείο και αν πρόκειται
		για φάκελο βάζει και το '/'.
		

	-sender_child.c :
		Αυτό το πρόγραμμα καλείται από το αρχείο main.c μέσω της exec και η δουλεία του
		είναι να στείλει τα αρχεία από το input_dir στο pipe ώστε να τα διαβάσει ο άλλος
		client.Για να το κάνει αυτό φτιάχνει το όνομα του pipe με το μονοπάτι στον
		common_dir , αν δεν υπάρχει το pipe δηλ δεν τον έχει δημιουργήσει ο receiver
		το φτιάχνει και το ανοίγει με O_WRONLY.Έπειτα υπολογίζω το useless_part , 
		ουσιαστικά κρατάω ένα "δείκτη" στο τελευταίο κομμάτι του μονοπατιού καθώς
		αυτό είναι το μόνο που ενδιαφέρει τον receiver μετά καλώ την αναδρομική συνάρτηση
		sendFiles η οποία στέλνει όλους τους φάκελους και τα αρχεία που υπάρχουν στο
		input_dir.Η συνάρτηση δουλεύει ως εξής , ακολουθεί το πρωτόκολλο της άσκησης
		αρχικά στέλνω τα πρώτα 2 βήματα και έπειτα ελέγχω αν είναι φάκελος όπου καλώ την
		ίδια συνάρτηση για κάθε στοιχείο του φακέλου ή αν είναι αρχείο εκτελώ τα βήματα
		3,4 , Στο βήμα 4 στέλνω κάθε φορά buffer_size bytes εκτός αν το υπόλοιπο είναι
		μικρότερο από αυτό , οπότε στέλνω ότι έχει μείνει.Στο τέλος βάζω στο logfile
		το όνομα του αρχείου και πόσα bytes μεταφέρθηκαν στο pipe κατα την μεταφορά.
		***Παράδειγμα για το useless_part , αν θέλουμε να στείλουμε ./input-files/infiles/Cy/
		αυτό σημαίνει ότι πρέπει να μεταφέρουμε τον φάκελο Cy/ και όλα τα περιχόμενά του
		άρα όλο το προηγούμενο (./input-files/infiles/) είναι πληροφορία άχρηστη για τον
		receiver_child οπότε δεν χρειάζεται να την μεταφέρουμε.


	-receiver_child.c :
		Αυτό το πρόγραμμα καλείται από το αρχείο main.c μέσω της exec και η δουλεία του
		είναι να λαμβάνει τα αρχεία που του στέλνει ένας άλλος client μέσο του pipe.Για
		να το κάνει αυτό φτιάχνει το όνομα του pipe με το μονοπάτι στον common_dir , αν
		δεν υπάρχει το pipe δηλ δεν τον έχει δημιουργήσει ο sender το φτιάχνει και το
		ανοίγει με O_RDONLY.Στη συνέχεια φτιάχνει στο mirror έναν φάκελο με όνομα το
		id του sender όπου εκεί θα βάλει αυτά που θα διαβάσει.Διαβάζει με βάση το
		πρωτόκολλο αν είναι φάκελος τότε ακολουθεί μόνο τα πρώτα 2 βήματα αλλιώς τα
		εκτελεί όλα.Όταν διαβάσει το βήμα 2 τότε δημιουργεί το αντίστοιχο αρχείο η φάκελο.
		Ο έλεγχος για το αν είναι φάκελος ή αρχείο γίνεται κοιτώντας τον τελευταίο
		χαρακτήρα , αν είναι '/' τότε έχουμε φάκελο.


	-cleaner_child.c :
		Αυτό το πρόγραμμα καλείται από το αρχείο main.c μέσω της exec και η δουλεία του
		είναι να καθαρίσει από τον mirror του το φάκελο με τα αρχεία που πήρε από τον
		εκάστωτε client.Για να το κάνει αυτό φτιάχνει το μονοπάτι προς αυτόν τον φάκελο
		και καλεί την συνάρτηση cleanSubdirFromMirror η οποία αναδρομικά διαγράφει όλα τα
		στοιχεία του φακέλου.Η συνάρτηση αυτή αρχικά ελέγχει αν πρόκειται για φάκελο ή για
		αρχείο. Στην περίπτωση του αρχείου απλά το διαγράφει . Στην περίπτωση του φακέλου
		τον ανοίγει , και καλεί την ίδια συνάρτηση για όλα τα στοιχεία που έχει μέσα του
		(εκτός των "." και "..") και τέλος τον κλείνει και τον διαγράφει.


	-list.h :
		Η δομή listnode είναι μια λίστα που κρατάει τα *.id στο πεδίο str και το πεδίο
		still_exist που με βοηθάει στο να αναγνωρίζω αν κάποιος έχει φύγει απο το σύστημα.
		Η δομή list είναι η "κεφαλή" της δομής listnode.
	-list.c :
		- void initializeList(list **l) : Μία απλή συνάρτηση που φτιάχνει την "κεφαλή" της
		λίστας και αρχικοποιει σε NULL την αρχη και το τέλος της καθώς αρχικά είναι αδεια.
		- void insertList(list *l,char *element) : Σε αυτήν την συνάρτηση βάζω το νέο
		στοιχείο στο τέλος της λίστας , και αν πριν την εισαγωγή είναι άδεια , δίνω τιμή και
		στο start πεδίο που το κάνω =end , το still_exist το κάνω 1 καθώς μόλις το διάβασα
		και προφανώς υπάρχει.
		- int searchList(list *l,char *element) : Σε αυτήν την συνάρτηση ψάχνω ένα
		συγκεκριμένο αρχείο , αν το βρώ μαρκάρω το still_exist με 1 και επιστρέφω 1 για
		success ,αλλίως 0.
		- void printList(list *l) : Μία απλή συνάρτηση που τυπώνει την λίστα.
		- void destroyList(list **l) : Μία απλή συνάρτηση που διαγράφει όλους τους κόμβους
		της λίστας και την "κεφαλή".
		- void initializeZeroList(list *l) : Μία απλή συνάρτηση που μηδενίζει-αρχικοποιεί
		όλα τα still_exist της λίστας σε 0.
		- char *searchAndDeleteZeroList(list *l) : Σε αυτήν την συνάρτηση ψάχνω για τους
		κόμβους της λίστας με still_exist==0 , δηλ αρχεία που έχουν διαγραφεί απο τον
		φάκελο common.Βρίσκω το πρώτο από αυτά , διαγράφω τον κόμβο από την λίστα και
		επιστρέφω το όνομα,αλλίως NULL.Όταν η συνάρτηση επιστρέψει NULL τότε ξέρει η 
		main ότι δεν υπάρχει άλλο αρχείο που λείπει.


B) create_infiles.sh :
	-Αρχικά ελέγχω αν έχουν δωθεί ακριβώς 4 arguments.
	-Τα 2-4 πρέπει να είναι αριθμοί και μεγαλύτεροι ή ίσοι με 0.
	-Για το πρώτο όρισμα ελέγχω αν υπάρχει, αν δεν υπάρχει τον δημιουργώ
	-Μετά δημιουργώ τα directory names , με την RANDOM και το % παίρνω έναν αριθμό στο
	εύρος (1-8) και έπειτα με την χρήση της urandom παίρνω τυχαία χαρακτήρες ώστε να φτιάξω
	το όνομα του directory. Τα ονόματα αποθηκεύονται στην λίστα DIRECTORY_NAMES.
	-Στην συνέχεια φτιάχνω τα directory , όπως λέει η άσκηση πρέπει να τα κατανέμουμαι σε
	LEVELS επίπεδα , για να το κάνω έχω τον αρχικό κατάλογο απο τα ορίσματα ,
	και παίρνω με την σειρά τα ονόματα που έφτιαξα πριν.Αν ο COUNTER είναι δεν πολλαπλάσιο του
	LEVELS τότε παίρνουμε τον τελευταίο φάκελο που φτιάξαμε και εκεί μέσα δημιουργούμε τον νέο
	φάκελο.Σε αντίθετη περίπτωση ξεκινάμε από τον DIR_NAME(το πρώτο όρισμα).Με την σειρά που τα
	δημιουργώ τα βάζω (με το μονοπάτι τους) στην λίστα DIRECTORIES , για να με βοηθήσει στο
	επόμενο βήμα.
	-Με όμοιο τρόπο δημιουργώ τα ονόματα των αρχείων και ως μονοπάτι σε αυτά , δηλ σε ποιον
	φάκελο ανήκουν , παίρνω με την σειρά και κυκλικά(δηλ οταν τελειωσουν πάω πάλι στο πρώτο)
	τους φακέλους από την λίστα DIRECTORIES.Έπειτα δημιουργώ τα αρχεία με touch και με παρόμοιο
	τρόπο που έφτιαχνα πριν τα ονόματα τώρα φτιάχνω το περιχόμενο των αρχείων , με την διαφορά
	ότι η random έχει εύρος (0 , 32767) που είναι πιο λίγο από αυτό που χρειαζόμαστε , οπότε
	μεγαλώνω τον αριθμό κάνοντας έναν καινούργιο με τα διπλά ψηφία με τον τρόπο που φαίνεται στα
	σχόλια.
	-Στο πρόγραμμα έχω αφήσει κάποιες echo σχολιασμένες , μπορείται να τις χρησιμοποιήσεται
	για να ελέγξετε την ορθότητα του bash.
	

c) get_stats.sh :
	-Αρχικά αρχικοποιώ όλες τις μεταβλητές που θα χρειαστώ , δηλ μία λίστα με τα id , το πλήθος
	το μέγιστο και το ελάχιστο απο αυτά.Επιπλέων 2 μεταβλητές για τα bytes που οι clients
	έδωσαν και έλαβαν από τα pipes , 2 μεταβλητές για το πλήθος των αρχείων που έδωσαν και
	έλαβαν από τα pipes και τέλος τον αριθμό τον clients που αποχώρησαν από το σύστημα.
	-Διαβάζω γραμμή γραμμή το input από το cat των logfiles και μέσα έχω μία for η οποία
	σπάει την γραμμή σε λέξεις.Η κάθε γραμμή έχει 2 ή 3 λέξεις και είναι μία από τις εξής
	περιπτώσεις.
		1)id "id client"
		2)send/receive "bytes" ,για φακέλους το το πλήθος των bytes που
			χρειάστηκαν για να μεταφερθεί ο φακελος(οχι τα περιεχόμενά του)
		3)send/receive "path file" "bytes" ,για αρχεία , το πλήθος των bytes που
			χρειάστηκαν για να μεταφερθεί το αρχείο
		4)client left id="id client"
	Χρησιμοποιώ την μεταβλητή WHICH_WORD για να ξέρω σε ποια λέξη της γραμμής βρίσκομαι καθώς
	και την μεταβλητή TYPE που μου δίνει πληροφορίες για την πρτη λέξη.
	Αν η πρώτη λέξη είναι client τότε απλά αυξάνω την μεταβλητή NUMBER_OF_CLIENTS_LEFT , σε
	αντίθετη περίπτωση βάζω στην TYPE την αντίστοιχη τιμή
	-Όταν διαβάσουμε την δεύτερη λέξη και έχουμε TYPE==1 τότε ξέρουμε ότι η δεύτερη λέξη έιναι
	το id του client οπότε το βάζω στην λίστα αυξάνω το NUMBER_OF_IDS και ανανεώνω το μέγιστο
	και το ελάχιστο αν χρειαστεί, Αν έχουμε TYPE==2 ή TYPE==3 (αυτές οι 2 περιπτώσεις
	αντιμετωπίζονται παρόμοια) και η δεύτερη λέξη είναι αριθμός τότε ξέρουμε ότι
	πρόκειται για μεταφορά φακέλου οπότε αυξάνω τα BYTES_SEND ή BYTES_RECEIVED ανάλογα το
	TYPE.
	-Αν δεν είναι αριθμός τότε έχουμε μεταφορά αρχείου ,διαβάζουμε την τρίτη λέξη και
	κάνουμε ότι και στην προηγούμενη περίπτωση και επιπλέων αυξάνουμε FILES_SEND ή
	FILES_RECEIVED.
	-Στην συνέχεια εκτυπώνει τα αποτελέσματα και τερματίζει το πρόγραμμα.
